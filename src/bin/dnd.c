#include <Elementary.h>
#include "main.h"
#include "win.h"
#include "winvid.h"
#include "winlist.h"
#include "dnd.h"

void
_cb_drag_enter(void *data EINA_UNUSED, Evas_Object *o EINA_UNUSED)
{
   printf("dnd enter\n");
}

void
_cb_drag_leave(void *data EINA_UNUSED, Evas_Object *o EINA_UNUSED)
{
   printf("dnd leave\n");
}

void
_cb_drag_pos(void *data EINA_UNUSED, Evas_Object *o EINA_UNUSED, Evas_Coord x EINA_UNUSED, Evas_Coord y EINA_UNUSED, Elm_Xdnd_Action action EINA_UNUSED)
{
   /* printf("dnd at %i %i act:%i\n", x, y, action); */
}

static int
_xtov(char x)
{
   if ((x >= '0') && (x <= '9')) return x - '0';
   if ((x >= 'a') && (x <= 'f')) return 10 + (x - 'a');
   if ((x >= 'A') && (x <= 'F')) return 10 + (x - 'A');
   return 0;
}

static char *
_escape_parse(const char *str)
{
   char *dest = malloc(strlen(str) + 1);
   char *d;
   const char *s;

   for (d = dest, s = str; *s; d++)
     {
        if (s[0] == '%')
          {
             if (s[1] && s[2])
               {
                  *d = (_xtov(s[1]) << 4) | (_xtov(s[2]));
                  s += 3;
               }
             else s++;
          }
        else
          {
             *d = s[0];
             s++;
          }
     }
   *d = 0;
   return dest;
}

static Eina_Bool
_recurse_dir(Evas_Object *win, const char *path)
{
   Eina_Bool ret = EINA_FALSE;
   Eina_List *ls, *l;
   char *p, *escape;
   const char *full;

   ls = ecore_file_ls(path);
   EINA_LIST_FOREACH(ls, l, p)
     {
        escape = _escape_parse(p);
        full = eina_stringshare_printf("%s/%s", path, escape);
        free(escape);
        if (ecore_file_is_dir(full))
          {
             ret = _recurse_dir(win, full);
             eina_stringshare_del(full);
             continue;
          }

        printf("inserting '%s'\n", full);
        win_video_insert(win, full);
        eina_stringshare_del(full);
        ret = EINA_TRUE;
     }

   EINA_LIST_FREE(ls, p)
     free(p);

   return ret;
}

Eina_Bool
_cb_drop(void *data, Evas_Object *o EINA_UNUSED, Elm_Selection_Data *ev)
{
   Evas_Object *win = data;
   Eina_Bool inserted = EINA_FALSE;

   if (!ev->data) return EINA_TRUE;
   if (strchr(ev->data, '\n'))
     {
        char *p, *p2, *p3, *tb, *tt;
        
        tb = malloc(strlen(ev->data) + 1);
        if (tb)
          {
             for (p = ev->data; p;)
               {
                  p2 = strchr(p, '\n');
                  p3 = strchr(p, '\r');
                  if (p2 && p3)
                    {
                       if (p3 < p2) p2 = p3;
                    }
                  else if (!p2) p3 = p2;
                  if (p2)
                    {
                       strncpy(tb, p, p2 - p);
                       tb[p2 - p] = 0;
                       p = p2;
                       while ((*p) && (isspace(*p))) p++;
                       if (strlen(tb) > 0)
                         {
                            tt = _escape_parse(tb);
                            if (tt)
                              {
                                 if (ecore_file_is_dir(tt))
                                   {
                                      inserted = _recurse_dir(win, tt);
                                   }
                                 else
                                   {
                                      win_video_insert(win, tt);
                                      inserted = EINA_TRUE;
                                   }
                                 free(tt);
                              }
                         }
                    }
                  else
                    {
                       strcpy(tb, p);
                       if (strlen(tb) > 0)
                         {
                            tt = _escape_parse(tb);
                            if (tt)
                              {
                                 if (ecore_file_is_dir(tt))
                                   {
                                      inserted = _recurse_dir(win, tt);
                                   }
                                 else
                                   {
                                      win_video_insert(win, tt);
                                      inserted = EINA_TRUE;
                                   }
                                 free(tt);
                              }
                         }
                       break;
                    }
               }
             free(tb);
          }
     }
   else
     {
        char *tt = _escape_parse(ev->data);
        if (tt)
          {
             if (ecore_file_is_dir(tt))
               {
                  inserted = _recurse_dir(win, tt);
               }
             else
               {
                  win_video_insert(win, tt);
                  inserted = EINA_TRUE;
               }
             free(tt);
          }
     }
   if (inserted)
     {
        win_video_next(win);
        win_list_content_update(win);
     }
   return EINA_TRUE;
}

void
dnd_init(Evas_Object *win, Evas_Object *tgt)
{
   elm_drop_target_add(tgt,
                       ELM_SEL_FORMAT_TEXT | ELM_SEL_FORMAT_IMAGE,
                       _cb_drag_enter, win,
                       _cb_drag_leave, win,
                       _cb_drag_pos, win,
                       _cb_drop, win);
}
